{"name":"Phylocaml","tagline":"Phylogenetic Library based on a factoring of POY.","body":"phylocaml\r\n=========\r\nA Phylogenetic Library based on a refactoring of [POY](http://code.google.com/p/poy).\r\n\r\nThe **goal** of *phylocaml* is to use the experience from *POY 3/4/5* to develop a\r\nlibrary. A major reason for this refactoring is that we need the ability to\r\nsupport different types of topologies from our previous implementations.\r\nAlthough our utility is to develop a rooted network approach, we believe the\r\nframework can be used in general for other types of topologies and offers us a\r\nway to write a powerful library for bioinformatics research.\r\n\r\nWe are also taking the approach to utilize many of the new features that the\r\nOCaml team has developed over the years, prefer a standard library (Core), and\r\nbecome more idiomatic to the standards developed since the initial versions.\r\n\r\n\r\nTable of Contents\r\n=================\r\n\r\n+ Dependencies\r\n+ Configure and Install\r\n+ Quick Start\r\n  + Overview of Diagnosis Modules\r\n  + Overview of Search Modules\r\n  + Overview of Utility Modules\r\n+ Test Framework\r\n+ Design Choices and Rationale\r\n+ Contact/Location Information\r\n\r\n\r\nDependencies\r\n============\r\n+ [OCaml](http://caml.inria.fr/ocaml/) (4.00.1+)\r\n+ [Pareto](http://github.com/superbobry/pareto/)\r\n+ [Findlib](http://projects.camlcity.org/projects/findlib.html)\r\n\r\n\r\nConfigure and Install\r\n=====================\r\nrun,\r\n    make install\r\n\r\n\r\nQuick Start\r\n===========\r\n\r\nOverview of Diagnosis Modules\r\n-----------------------------\r\n\r\nThe diagnosis module contains the abilities to take a topology and node data and\r\nassign optimal states, model parameters and assign a utility function (cost)\r\nto the topology.\r\n\r\nCurrently, in POY 5, we encapsulate this pretty well. There is some leaking with\r\nmodules that do things to very specific data, but they are few and far between.\r\nThis refactoring will be an effort to eliminate this leakage. We believe a\r\nfunctor approach of a diagnosis module will be effective. In this way we can\r\nimplement a parallel diagnosis module that can plug into whatever the diagnosis\r\nmodule uses (the Search module for example) as well as deal with unforeseen\r\nissues with networks or more complex topologies in optimizing states.\r\n\r\n                                                            +-------+\r\n       +------------+----------+-------------+----------+---+---+   |\r\n       | Likelihood | Sequence | NonAdditive | Additive |  Set  |<--+--+\r\n       +------------+----------+-------------+----------+-------+      |\r\n                                                                       |\r\n          +--------------+-----------+         +--------+----------+   |\r\n          |              | Node      |-------->|        | NodeData |---+\r\n          |              +-----------+         | Node   +----------+\r\n          | Diagnosis    | Root      |-------->|        | Compare  |\r\n          |              +-----------+         +--------+----------+\r\n          |              | PTopology |----+    +----------+   |\r\n          +--------------+-----------+    +--->| Topology |<--+\r\n                                               +----------+\r\n\r\n           Figure 1. Basic Module dependency diagram of a Diagnosis\r\n\r\n\r\nIn Figure 1, the diagnosis module is a functor about a node, root, and ptopo.\r\nThe topology designates a way to traverse the topology, and ptopology attaches\r\ndata to the nodes and roots. This allows separation between structure and gives\r\na common and basic interface to attach data to a topology. Topology additionally\r\ncontains a compare module for traversing a topology in a consistent way[^1].\r\n\r\nThe Node/Root module is a functor itself to apply a previously mentioned compare\r\nmodule and a data module that contains all the functions in the optimality\r\ncriteria (Likelihood, Additive, Chromosome, Genome, Sankoff, et cetera) all\r\nshare a common module interface (NodeData). Very close to what we have now with\r\nsome added components. \r\n\r\nNodes can also be abstracted to contain further features --laziness has been\r\nimportant, as well as a directional node for un-rooted trees in selecting the\r\nbest downpass assignments to perform an uppass on (each internal node of a\r\nbinary tree has three of these corresponding to each combination of 2 children).\r\nYou can see these implementations in the Node module.\r\n\r\nExample code to diagnose a tree with known data taxon data and tree file,\r\n\r\n    module Root = Node.Make1D (Tree.NodeComparator) (SequenceData)\r\n    module Node = Node.Make3D (Tree.NodeComparator) (SequenceData)\r\n    module PTree= Ptopology.Make (Tree)\r\n    module Diag = Diagnosis.Make (PTree) (Root) (Node)\r\n    let diagnose_tree taxa_data edges =\r\n        let nodes = List.map (fun x -> Node.of_data (SequenceData.of_string x)) taxa_data in\r\n        let tree = PTree.of_parsed edges nodes in\r\n        let tree = Diag.diagnose tree in\r\n        Printf.printf \"%s:[%d]\" (PTree.to_string tree) (Diag.total_cost tree)\r\n\r\n\r\nOverview of Search Modules\r\n--------------------------\r\n\r\nThe search framework will require thoughtfulness to be able to encompass a wide\r\nrange of known search heuristics, as well as unknown situations in regard to\r\nnetworks and other topologies. We would also like to spin this part off into a\r\ngeneral library if possible. Our problem, dealing with two NP-Hard problems\r\nrequires some extra thought that other packages do not often address. We can\r\nlook to current meta-heuristic literature to design a general library. Most of\r\nthese algorithms are dependent on a local search. At minimum this requires,\r\n\r\n+ Solution - A topology.\r\n+ Neighborhood- A way to generate solutions using local modifications\r\n+ Choose - A method to choose a single member of a neighborhood for\r\n  successive neighborhood searches.\r\n\r\nFull search procedures, like branch and bound will also have to be employed as\r\nwell to round out an exhaustive approach to search on small data-sets.\r\n\r\n    type local_search =\r\n      choose : (t -> t -> bool) ->\r\n        (module Neighborhood.S with type t = Diagnosis.t) ->\r\n          (module LocalTabu.S with type t = Diagnosis.t) -> t -> t\r\n\r\n    Figure 2. type definition for a local search\r\n\r\nIt is currently under consideration that the neighborhood be generated from a\r\nlazy-list. In this way, we believe a wide range of options and strategies can be\r\nemployed. The local search modules Neighborhood and LocalTabu are specialized to\r\nthe type of the topology. This allows multiple diagnosis modules to use the same\r\nNeighborhood for the same topology. This is important in Variable Neighborhood\r\nSearch especially and in general.\r\n\r\nThis local-search procedure can be used to build up a more global search\r\nprocedure that includes perturbations, a more robust tabu-search, and other\r\nfunctionalities for global optimization and meta-heuristics. These procedures\r\ncan be defined separately instead of a single all encompassing search function,\r\nand be parameterized about the specific requirements of the topology. In general\r\nmeta-heuristics can be separated into two categories:\r\n\r\nIterative Methods\r\n+ Simulated Annealing (with restart)\r\n+ Tabu-Search\r\n+ Greedy Randomized Adaptive Search Procedure (GRASP)\r\n+ Variable Neighborhood Search\r\n+ Guided Local Search\r\n+ Iterated Local Search\r\n\r\nPopulation Based Methods\r\n+ Scatter Search / Path Relinking\r\n+ Evolutionary Computation (eg, GA)\r\n+ Ant Colony Optimization\r\n+ Firefly Optimization\r\n\r\nThe potential to compose these methods into hyper-heuristics is still a\r\nquestion, but at the very least these methods encompass a wide range of ways\r\nto vary the degrees of Intensification and Diversification. Some questions\r\nremain regarding the search procedures,\r\n\r\n+ Will this design be robust enough for parallel computation and other types\r\n  of neighborhoods?\r\n+ Does the first-class module cause speed issues?\r\n+ Can neighborhoods be partitioned effectively with the scheme we have?\r\n+ Can the frame-work be generalized into its own library?\r\n\r\n\r\nOverview of Utility Modules\r\n---------------------------\r\n\r\nThese are a list of modules that can be composed and used to handle a wide range\r\nof data for different optimality criterion. These are oft interfaces to C\r\ndata-types and would be scripted to handle floats, doubles, ints, chars, long,\r\net cetera to accommodate a changing need. Special casing some would be\r\nappropriate to add vectorization to the mix, but previous/general\r\nimplementations and pure OCaml implementations would be built for verification\r\npurposes.\r\n\r\n+ CostMatrix - Handles median and cost assignments\r\n+ Sequence - Handles an ordered continuous set of characters in an alphabet\r\n+ Align - Algorithms to align sequences \r\n+ Alphabet - Handles codes and names association and type of alphabet to\r\n  generate a cost\\_matrix when paired with transformation matrix.\r\n+ FingerPrinting - Interface to create short tags of data-structures for tabu\r\n  managers in a search. Not required, else entire topology may be stored and\r\n  compared, or no tabus implemented. Also can be used for fusing to name\r\n  potential clades of the topology.\r\n+ LikelihoodModel - General storage for a likelihood model.\r\n\r\n\r\nTest Framework\r\n==============\r\n...\r\n\r\nDesign Choices and Rationale\r\n============================\r\n\r\n+ In nodes containing multiple directions and because of heuristics in\r\n  diagnosing un-rooted topologies, we need to know which directional node is\r\n  being queried. This can be done two different ways: by the parent or by the\r\n  children. This variant type is located in the node module and can be used in\r\n  any type of node for any topology.\r\n+ Traversing a topology in a consistent way is important for reproducibility\r\n  but this particular issue has to do with the ordering in which nodes enter a\r\n  function to produce the same results. For example, although\r\n  cost(a,b) = cost(b,a), it does not hold that median(a,b) = median(b,a). This\r\n  is because the traceback in the alignment matrix when faced with two equally\r\n  parsimonious alignments, must choose a direction. As these different\r\n  traversals build up the tree to the root, vastly different assignments and\r\n  costs can result. The different assignments/costs are correct none-the-less.\r\n  The final differences are taken care of in the uppass and the assignment\r\n  functions that optimize the internal states of the topology.\r\n+ Neighborhoods are defined by a first-class module passed to an enumeration\r\n  function. This neighborhood module will define how breaks and deltas are\r\n  generated. Deltas are a series of steps to transform a tree. Break, Join,\r\n  and re-root currently seem to be the only ones necessary for a full featured\r\n  neighborhood search, but this can be expanded if other options are needed\r\n  (for example, optimization of the tree if this doesn't have a place\r\n  elsewhere in the design of the application). The delta is associated with the\r\n  diagnosis module so the search can be as abstract as possible.\r\n+ The NodeComparator is built to generally satisfy the left/right or ordering\r\n  of children for medians[^1]. The design is abstract and depends on proper\r\n  functorizing of the node module with the topology. Currently it is not\r\n  known if this issue will arise with multiple parents in a topology\r\n  (reticulate nodes of networks), or if there is a better way to allow\r\n  consistency between functorized modules.\r\n\r\n\r\nContact/Location Information\r\n===================\r\n+ [Nicholas Lucaroni](mailto:nlucaroni@amnh.org)\r\n+ [Ward Wheeler](mailto:wheeler@amnh.org)\r\n+ [Lavanya Kannan] (mailto:lkannan@amnh.org)\r\n+ [Support Forum](https://groups.google.com/forum/?fromgroups#!forum/poy4)\r\n+ [Site on AMNH](http://research.amnh.org/scicomp/research/projects/invertebrate-zoology/poy?q=projects/poy.php)\r\n\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}